@using OpenCvSharp
@using Size = OpenCvSharp.Size
@using ImagingOps
@inherits CVComponent
@BaseComponentMarkup
<br />
<br />
@BaseButtonMarkup
<br />
<br />
 
<MudText>10 Features zoomed in to the feature</MudText>
@foreach (var item in Keypoint20Urls)
{  
    <MudImage Style="margin: 2px;" Src="@($"data:image/png;base64,{item}")"/> 
} 
<br />
<br/>
<br/>
@BaseCanvasMarkup

<br/>
 
@code {

    protected List<string> Keypoint20Urls { get; set; } = new();
    protected List<string> Keypoint10Urls { get; set; } = new();
    protected List<string> Keypoint2Urls { get; set; } = new();

    protected override async Task Process(Mat startFrameMat, Mat endFrameMat)
    { 
        using var grayMat = new Mat();
        Cv2.CvtColor(startFrameMat, grayMat, ColorConversionCodes.BGR2GRAY);


        // Initialize ORB detector 
        using (var orb = ORB.Create())
        {
            // Detect the keypoints and compute the descriptors
            KeyPoint[] keypoints;
            Mat descriptors = new Mat();
            orb.DetectAndCompute(grayMat, null, out keypoints, descriptors);

            // Draw keypoints 
            using var dstMat = startFrameMat.Clone();
            Cv2.DrawKeypoints(startFrameMat, keypoints, dstMat);

             
            DrawKeypoints(grayMat, keypoints, Keypoint20Urls); 

            await SetDstImage(dstMat);
        }
    }


    protected void DrawKeypoints(Mat initialGrayMat, KeyPoint[] initialKeypoints, List<string> urls)
    {
        // Parameters
        int enlargedSize = 100; // New size after enlargement

        foreach (var kp in initialKeypoints.Take(10)) // Just an example, processing the first 10 keypoints
        {
            int roiSize = (int)kp.Size;
            // Calculate the ROI bounds, ensuring they are within the image
            int x = Math.Max((int)kp.Pt.X - roiSize / 2, 0);
            int y = Math.Max((int)kp.Pt.Y - roiSize / 2, 0);
            x = Math.Min(x, initialGrayMat.Width - roiSize);
            y = Math.Min(y, initialGrayMat.Height - roiSize);

            // Define the ROI around the keypoint
            Rect roi = new Rect(x, y, roiSize, roiSize);

            // Extract the ROI from the original image
            Mat keypointROI = new Mat(initialGrayMat, roi);

            // Resize the extracted ROI
            Mat enlargedROI = new Mat();
            Cv2.Resize(keypointROI, enlargedROI, new Size(enlargedSize, enlargedSize), 0, 0, InterpolationFlags.Cubic);

            if (roiSize == 5)
            {
                Mat blurred = new Mat();
                Cv2.GaussianBlur(enlargedROI, blurred, new Size(0, 0), 3);

                // Enhance the original image by adding the detail back to it
                Mat sharpened = new Mat();
                double alpha = 1.5; // Coefficient for the original image
                double beta = -0.5; // Coefficient for the blurred image
                double gamma = 0; // Scalar added to each sum
                Cv2.AddWeighted(enlargedROI, alpha, blurred, beta, gamma, sharpened);

                double medianValue = Cv2.Mean(enlargedROI).Val0; // Assuming grayscale image
                double lowerThreshold = Math.Max(0, (1.0 - 0.33) * medianValue);
                double upperThreshold = Math.Min(255, (1.0 + 0.33) * medianValue);

                urls.Add(ImageOps.MatToBase64(enlargedROI));

                // Mat edges = new Mat();
                // Cv2.Canny(enlargedROI, edges, lowerThreshold, upperThreshold);
                // urls.Add(ImageOps.MatToBase64(edges));
            }
            else
            {
                urls.Add(ImageOps.MatToBase64(enlargedROI));
            }

        }
    }


}
